# Date1 - 20220626(日)
## トレンド
1. AppleはSiriKit、Game Center、CoreML、ARKitなどの多くのフレームワークを次々に導入しました。これらのテクノロジーとそれに関連するドキュメントは、毎年増え続けている。ドキュメントは思ったほど速く成長しないかもしれません。
2. Objective-CからSwiftへ：Appleは、iOS開発のためにAppleがサポートする主要言語としてObjective-CからSwiftに移行。
3. UIKitからSwiftUIへ：Appleは、ユーザーインターフェイス開発のためにUIKitよりもSwiftUIの宣伝を開始。

今日アプリを開発ための多くのテクノロジー、ベストプラクティス、およびテクニックを身につける。


# プロジェクトの組織:機能のグループ化

![start](MarkdownImages/HGrouping_VS_VGrouping.png?cropResize=40,40)

この図は、水平方向と垂直方向のグループ化の違いを示しています。最初のアプローチでは、類似性によってグループ化されたコードの断片があります。たとえば、ネットワーク層のコードは一緒であり、モデル層のコードは一緒です。

2番目の図は、用途別にグループ化されたコードを示しています。したがって、相互に関連するコードをグループ化します。このタイプの組織は、機能のグループ化と呼ばれ、アプリの各部分の境界を定義するため、適切な場所に適切なコードがあります。これにはいくつかの利点があります。

グループの名前はすでにコードから何を期待できるかを示しているため、コードのナビゲートと検索が容易になります。
同じ目的に関連するコードのみを含めることで、凝集度の高いグループを作成します。
モジュラーコードの作成を容易にします。  
  
プロジェクトが大きくなるにつれて、コードを維持してアプリの各部分を見つけることが難しくなる可能性があります。そのため、プロジェクトの組織を早い段階で検討することが不可欠です。このような組織パターンに従うことで、問題を軽減し、コードを高い凝集度と低い結合度で維持できます。

## より優れた再利用可能なコードを作成する方法

1. 凝集度が高く結合度が低いコード  
2. プロトコル指向プログラミング（POP）
3. SOLID   
・単一責任の原則(Single Responsibility Principle)：  
モジュール、クラス、または関数は、単一のタスクに焦点を合わせて、単一の目的を担当する必要があります。この単一の焦点は、問題全体を解決することにより、不均衡に成長しないコードを作成するのに役立ちます。  
オープン/クローズの原則(Open/Closed Principle)：  
拡張のためにオープンであるが変更のためにクローズされているモジュール、クラス、および関数を定義します。つまり、実装を変更せずに動作を拡張します。  
・リスコフの置換原則(Liskov Substitution Principle)：  
コードを壊さずにクラスをサブクラスに置き換えます。同じプロトコルに準拠している限り、別のタイプを使用できるプロトコルを使用して、このアイデアをSwiftに適用することもできます。  
・インターフェイス分離の原則(Interface Segregation Principle)：  
モジュールは、使用しない要件に依存するべきではありません。タイプの動作全体を定義するプロトコルを作成する代わりに、他のユースケースをカバーする別のプロトコルを作成すると、モジュールが必要なものだけを使用できるようになります。  
・依存性逆転の原則(Dependency Inversion Principle)：  
モジュールは外部の依存関係に依存するべきではありませんが、モジュールはその要件を定義する必要があります。モジュールは他のモジュールではなく、抽象化に依存する必要があると記載されています。たとえば、この原則に従うことで、アプリの他の部分の具体的な実装に依存することなく、ネットワークモジュールを個別にテストできます。